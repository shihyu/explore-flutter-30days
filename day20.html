<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Day 20: Riverpod 的開發多元性以及日常使用技巧！Provider 該如何選擇？ - Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-20-riverpod-的開發多元性以及日常使用技巧provider-該如何選擇"><a class="header" href="#day-20-riverpod-的開發多元性以及日常使用技巧provider-該如何選擇">Day 20: Riverpod 的開發多元性以及日常使用技巧！Provider 該如何選擇？</a></h1>
<ul>
<li>發布時間：2023-10-05 14:40:07</li>
<li>原文連結：<a href="https://ithelp.ithome.com.tw/articles/10334626">https://ithelp.ithome.com.tw/articles/10334626</a></li>
<li>系列標記：探索 Flutter 由裡到外，三十天帶你前往進階系列 第 20 篇</li>
</ul>
<p><img src="images/20120687ljLfmVOv4I.png" alt="" /></p>
<p>Riverpod 是什麼？相信大家都已經有初步了解了，甚至大家都已經運用在自己的專案了對吧？它本身的使用方式很多樣，是個很靈活的框架，但在很方便開發的同時，也很容易造成多成員開發方式不同的問題，所以需要有規範去執行，不管是個人還是團隊都一樣，如果本身對專案與程式碼品質有要求的話，相信大家都是對自己很有要求的開發者。</p>
<p>本文要講解幾種 Riverpod 的日常使用，在同一個需求情境下，其實有多種能完成的方式，如何做正確選擇，需要等你們實際玩過才會得知。另外，也會分享一些開發技巧，希望能夠有效的提升開發效率，進而讓我們喜歡使用 Riverpod。話不多說，馬上開始吧</p>
<hr />
<p>假設今天我們要請求 API 取得 User 資料，會如何使用？其實用 <strong>Provider</strong>、<strong>FutureProvider</strong>、<strong>Notifier</strong>、<strong>AsyncNotifier</strong> 等等都可以實作，差別就是根據操作情境來選擇，以下一起來看看每個 Provider 使用的差異性。</p>
<h2 id="1-provider"><a class="header" href="#1-provider">1. Provider</a></h2>
<p>使用基本的 Provider 來處理非同步操作。以範例來看，實際上 Provider 可以執行非同步任務，使用 async 將資料回傳。</p>
<pre><code class="language-dart">final userProvider = Provider((ref) async {
    return ref.watch(userRepositoryProvider).getUser();
});
</code></pre>
<p>所以外部可以直接 await <code>ref.read()</code> ，就跟我們使用一般的 async method 一樣。不同的是，使用 Provider 同時也會將第一次的結果狀態緩存起來，也就是說，當第二次第三次存取 <strong>userProvider</strong> 的時候，會回傳剛剛處理的結果，不會在執行新的請求。</p>
<pre><code class="language-dart">final user = await ref.read(userProvider);
debugPrint(user.toJson().toString());
// {id: 1, name: Yii Chen}
</code></pre>
<p>這時候可能有人會問，可以每次存取的時候都重新請求嗎？當然可以，不過需要額外的釋放操作，也就是使用 <code>invalidate()</code>，使指定 Provider 無效，將緩存的狀態丟掉，同時 Provider 也被釋放了，在下次存取時就會重頭來過。</p>
<pre><code class="language-dart">final user = await ref.read(userProvider);
ref.invalidate(userProvider);

debugPrint(user.toJson().toString());
// {id: 1, name: Yii Chen}
</code></pre>
<p>當然我們也可以使用 <code>ref.refresh()</code>，它跟 <code>invalidate()</code> 差異就是直接重新來過並且回傳結果，其實過程就是先執行釋放接著再存取一次，算是個更便捷的 API。</p>
<pre><code class="language-dart">final user = await ref.refresh(userProvider);

debugPrint(user.toJson().toString());
// {id: 1, name: Yii Chen}
</code></pre>
<p><code>refresh()</code> 就相當於先 <code>invalidate()</code> 在 <code>read()</code>，可以根據喜好還有情境去選擇。</p>
<pre><code class="language-dart">final user = await ref.refresh(userProvider);

==

ref.invalidate(userProvider);
final user = await ref.read(userProvider);
</code></pre>
<h2 id="2-futureprovider"><a class="header" href="#2-futureprovider">2. FutureProvider</a></h2>
<p>使用 FutureProvider 請求 User 資料。大家應該知道會傳的結果都是 AsyncValue，因為是非同步就會有載入中、成功和錯誤三種狀態，所以大家常用的情境是跟 UI 綁在一起，根據狀態來顯示對應的元件。透過 <code>ref.watch()</code> 監聽狀態的方式，我們可以這樣實作</p>
<pre><code class="language-dart">final userProvider = FutureProvider.autoDispose((ref) async {
    return ref.watch(userRepositoryProvider).getUser();
});

// In UI
ref.watch(userProvider).when(
    data: (User data) {
        return Text(data.name);
    },
    loading: () {
        return const CircularProgressIndicator();
    },
    error: (error, stacktrace) {
        return const Text('Oops!');
    },
)
</code></pre>
<blockquote>
<p>範例中的 Provider 我都會使用 <code>autoDispose</code> modifier，它主要的功能就是當 Provider 沒有被使用被監聽的時候釋放掉，有效節省資源，避免忘記處理記憶體。在大部分的情境中，需要自動釋放的時刻會比較多，可以養成習慣。甚至如果使用 Riverpod 的 Codegen 寫法的話(本文不會講解)，預設 Provider 都是 <code>autoDispose</code>，所以開發起來就更方便。當然如果大家會自己管理釋放時機的話就不需要添加，一樣的受根據需求去做選擇。</p>
</blockquote>
<p>這時候也許有人會問，我可以跟 Provider 或是一般非同步方法一樣，直接呼叫並取得結果嗎？當然可以。使用 Provider 擁有的 <code>future</code> 屬性，可以讓我們取得結果，同時將結果緩存起來，所以如果之後在存取 Provider 的時候，會回傳舊的資料。</p>
<pre><code class="language-dart">final user = await ref.read(userProvider.future);

debugPrint(user.toJson().toString());
// {id: 1, name: Yii Chen}
</code></pre>
<h2 id="3-notifierprovider"><a class="header" href="#3-notifierprovider">3. NotifierProvider</a></h2>
<p>使用 NotifierProvider 請求 User 資料。Notifier 不同的是初始化寫在 <code>build()</code>，我們可以在內部定義一些相關的方法來做額外的一些處理，可以存取狀態或是更新狀態，在此範例增加了兩個方法， <code>getUser()</code> 取得資料、 <code>updateUser()</code> 更新狀態為新的 User。</p>
<p>Notifier 本身是同步的，所以回傳值就是我們的 User，不過因為預設值的部分，在一開始我們還沒有請求資料所以預設為 null。接著再呼叫裡面寫好的方法 <code>getUser()</code>，等請求成功之後再進行狀態的更新，這時候畫面也會同時反應。</p>
<pre><code class="language-dart">final userProvider = NotifierProvider.autoDispose&lt;UserNotifier, User?&gt;(UserNotifier.new);

class UserNotifier extends AutoDisposeNotifier&lt;User?&gt; {
    @override
    User? build() {
        getUser();

        return null;
    }

    Future&lt;User&gt; getUser() async {
        final user = await ref.read(userRepositoryProvider).getUser();
        state = user;

        return user;
    }

    Future&lt;void&gt; updateUser(User user) async {
        state = user;
    }
}
</code></pre>
<p>在 UI Code，一開始的去讀取 <strong>userProvider</strong>，這時候就會觸發 Notifier 裡的 <code>build()</code> 並請求 User 資料。接著在使用 <code>watch()</code> 監聽狀態變化，等待更新後同步 rebuild。而在這裡因為狀態一開始預設為 null，所以如果點擊按鈕要更新的話，先檢查是否為 null，這裡透過 Dart3 的 If-Case Matching 幫忙檢查，有值我們才呼叫 <code>updateUser()</code> 去更新狀態。</p>
<pre><code class="language-dart">@override
void initState() {
  super.initState();

  ref.read(userProvider);
}

@override
Widget build(BuildContext context) {
    final user = ref.watch(userProvider);

    return Scaffold(
        body: Center(
            child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                    Text(user?.name ?? ''),
                    ElevatedButton(
                        onPressed: () {
                            final newUser = user?.copyWith(id: 2, name: 'Jay');
                            if (newUser case final newUser?) {
                                ref.read(userProvider.notifier).updateUser(newUser);
                            }
                        },
                        child: const Text('Update User'),
                    ),
                ],
            ),
        ),
    );
}
</code></pre>
<p><img src="images/gJG2Skm.gif" alt="NotifierProvider" /></p>
<p>如果要前面的跟 Provider 一樣直接取得 User 呢？就可以把 Notifier 當作 Controller，透過裡面的 <code>getUser()</code> 直接取得資料。當然取得後 <strong>userProvider</strong> 裡的狀態也會被刷新。</p>
<pre><code class="language-dart">final user = await ref.read(userProvider.notifier).getUser();

debugPrint(user.toJson().toString());
// {id: 1, name: Yii Chen}
</code></pre>
<hr />
<h2 id="4-asyncnotifierprovider"><a class="header" href="#4-asyncnotifierprovider">4. AsyncNotifierProvider</a></h2>
<p>使用 AsyncNotifierProvider 請求 User 資料。以範例來看，跟 Notifier 類似，只是它專門處理非同步狀態，狀態會被 AsyncValue 包裹，這樣的好處是當我們存取 Provider 時也會有 Loading 跟 Error 狀態可以處理，直接針對幾個狀態去顯示對應的 UI，不需要額外在自定義相關狀態。</p>
<pre><code class="language-dart">final userProvider = AsyncNotifierProvider.autoDispose&lt;UserNotifier, User&gt;(UserNotifier.new);

class UserNotifier extends AutoDisposeAsyncNotifier&lt;User&gt; {

    @override
    FutureOr&lt;User&gt; build() {
        return getUser();
    }

    Future&lt;User&gt; getUser() async {
        final user = await ref.read(userRepositoryProvider).getUser();

        return user;
    }

    void updateUser(User user) {
        update((data) =&gt; user);
    }

}
</code></pre>
<p>UI Code 的寫法都差不多，在這裡新增了一個按鈕，負責更新原本的 User 狀態。所以再點擊後，會呼叫 <strong>UserNotifier</strong> 的 <code>updateUser()</code>，將 User 設置給它，這時候畫面也同時響應、刷新。</p>
<pre><code class="language-dart">ref.watch(userProvider).when(
  data: (User data) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(data.name),
        ElevatedButton(
          onPressed: () {
            final newUser = data.copyWith(id: 2, name: 'Jay');
            ref.read(userProvider.notifier).updateUser(newUser);
          },
          child: const Text('Update User'),
        ),
      ],
    );
  },
  loading: () {
    return const CircularProgressIndicator();
  },
  error: (error, stacktrace) {
    return const Text('Oops!');
  },
)
</code></pre>
<p><img src="images/gJG2Skm.gif" alt="AsyncNotifierProvider" /></p>
<p>跟前面一樣，那 AsyncNotifierProvider 直接觸發非同步任務的方式呢？第一種方式透過 future，如果是第一次存取 Provider，就會初始化執行 <code>build()</code>，裡面會請求資料並緩存，而我們也可以拿到新的狀態回傳值。</p>
<pre><code class="language-dart">final user = await ref.read(userProvider.future);
</code></pre>
<p>第二種方式，跟 Notifier 一樣，直接呼叫 <code>getUser()</code> 取得最新資料，這樣的話就不會管緩存狀態，每次都會重新請求並取得結果。</p>
<pre><code class="language-dart">final user2 = await ref.read(userProvider.notifier).getUser();
</code></pre>
<h2 id="選擇方向"><a class="header" href="#選擇方向">選擇方向</a></h2>
<p>到這裡我們已經觀察了四種 Provider 對於相同需求的撰寫方式，實際當然需要根據情境、邏輯、資料流等等去選擇，不過這邊可以順便給大家幾個方向：</p>
<ul>
<li><strong>Provider</strong>
<ol>
<li>物件、服務提供者 → 讓很多情境、需求下都存取相同實體</li>
<li>資料反應者 → 負責監聽其他狀態，並提供處理後的緩存資料</li>
</ol>
</li>
<li><strong>FutureProvider</strong>
<ol>
<li>非同步執行者 → 單純取得非同步結果，沒有其他額外對於狀態的操作，例如：API 的 Get 請求、讀取資料庫</li>
</ol>
</li>
<li><strong>Notifier</strong>
<ol>
<li>邏輯與狀態的管理者 → 需要自定義某個需求、功能的狀態類，並透過其他操作控制狀態。例如：當成 feature 或 page 的 Controller、ViewModel、功能的集中處理地，當今天需要有載入或是錯誤的狀態，可以自定義，自行提供</li>
</ol>
</li>
<li><strong>AsyncNotifier</strong>
<ol>
<li>跟 Notifier 一樣，只是需要在初始就取得非同步數據，並且大部分操作都有非同步狀態的支援，像是 <strong>AsyncData</strong>、<strong>AsyncLoading</strong>、<strong>AsyncError</strong></li>
</ol>
</li>
</ul>
<h2 id="example---網路監聽"><a class="header" href="#example---網路監聽">Example - 網路監聽</a></h2>
<p>在 Flutter 開發，當我們需要檢查網路是否連接時，很常會使用 <code>connectivity_plus</code> 套件。以下整理了幾種檢查和存取網路狀態的方式，進而讓大家更了解 Riverpod 的靈活性。</p>
<h3 id="streamprovider"><a class="header" href="#streamprovider">StreamProvider</a></h3>
<p>使用 StreamProvider 創建一個 Stream，持續的給予最新狀態。</p>
<ol>
<li>首先創建 Connectivity 實體，並在一開始主動取得連線狀態，並 <strong>yield</strong> 新增第一個值給資料流</li>
<li>接著持續監聽狀態變化，當有更新時新增狀態給資料流，使用 <strong>yield</strong>*，處理</li>
</ol>
<pre><code class="language-dart">final hasInternetStreamProvider = StreamProvider.autoDispose&lt;bool&gt;((ref) async* {
    final connectivity = Connectivity();

    yield (await connectivity.checkConnectivity()).hasInternet;
    yield* connectivity.onConnectivityChanged.map((result) =&gt; result.hasInternet);
});
</code></pre>
<p>完成 UI 畫面根據網路狀態反應的需求<br />
<img src="images/20120687g0dttbsKgJ.png" alt="" /></p>
<pre><code class="language-dart">@override
Widget build(BuildContext context) {
    final hasInternet = ref.watch(hasInternetStreamProvider).value ?? false;

    return hasInternet ? const WelcomeInfoWidget() : const CircularProgressIndicator();
}
</code></pre>
<p>其中，看到 ConnectivityResult 有一個 <code>hasInternet</code> getter，它是自定義的 Extension api，方便後續的實作，方便快速。</p>
<pre><code class="language-dart">extension ConnectivityResultExtension on ConnectivityResult {
    bool get hasInternet =&gt; switch (this) {
        ConnectivityResult.mobile || ConnectivityResult.wifi =&gt; true,
        _ =&gt; false,
      };
}
</code></pre>
<h3 id="streamprovider---part2"><a class="header" href="#streamprovider---part2">StreamProvider - part2</a></h3>
<p>另一種寫法，使用自己的 StreamController 來管理資料流。</p>
<ol>
<li>首先這裡順便把 Connectivity 物件獨立出來，讓其他 Provider 共同存取它</li>
</ol>
<pre><code class="language-dart">final connectivityProvider = Provider&lt;Connectivity&gt;((ref) {
    return Connectivity();
});
</code></pre>
<ol start="2">
<li>使用 StreamProvider 搭上 <code>autoDispose()</code>，在 Provider 沒有使用時被釋放、銷毀</li>
<li>首先取得 connectivity 實體，並創建一個 StreamController，負責處理資料</li>
<li>跟前面範例一樣，先取得當前狀態並添加到 Stream，讓監聽者可以被通知</li>
<li>接著在 <code>onConnectivityChanged()</code> callback 等待資料更新，添加狀態給 Stream，讓外部監聽著收到通知，做後續處理與反應</li>
<li>最後關鍵點，需要在 <code>onDispose()</code> 將資源釋放</li>
</ol>
<pre><code class="language-dart">final hasInternetStreamProvider = StreamProvider.autoDispose&lt;bool&gt;((ref) async* {
    final connectivity = ref.watch(connectivityProvider);
    final streamController = StreamController&lt;bool&gt;();

    final currentStatus = (await connectivity.checkConnectivity()).hasInternet;
    streamController.add(currentStatus);

    final subscription = connectivity.onConnectivityChanged.listen((ConnectivityResult result) {
        switch (result) {
            case ConnectivityResult.mobile || ConnectivityResult.wifi:
                streamController.add(true);
            case _:
                streamController.add(false);
        }
    });

    ref.onDispose(() {
        subscription.cancel();
        streamController.close();
    });

    yield* streamController.stream;
});
</code></pre>
<p>UI 的寫法都一樣，根據狀態顯示元件<br />
<img src="images/20120687tUOarnT7W0.png" alt="" /></p>
<h3 id="notifierprovider"><a class="header" href="#notifierprovider">NotifierProvider</a></h3>
<p>使用 NotifierProvider 實作，方便將每個操作切分開來，實作過程都差不多。</p>
<ol>
<li>在 <code>build()</code> 給予初始值 false，因為還沒監聽到狀態變化</li>
<li>執行 <code>initConnectivity()</code>，持續等待狀態更新，有新的狀態就觸發 <code>onStateDetected()</code> 更改當前的緩存數據</li>
<li>最後在 <code>onDispose()</code> 釋放資源，結束 <strong>streamSubscription</strong> 物件</li>
</ol>
<pre><code class="language-dart">final hasInternetNotifierProvider =
    NotifierProvider.autoDispose&lt;InternetStatusNotifier, bool&gt;(InternetStatusNotifier.new);

class InternetStatusNotifier extends AutoDisposeNotifier&lt;bool&gt; {
    StreamSubscription&lt;ConnectivityResult&gt;? _streamSubscription;

    @override
    bool build() {
        initConnectivity();
        onDispose();

        return false;
    }

    void initConnectivity() {
        _streamSubscription = Connectivity().onConnectivityChanged.listen((ConnectivityResult result) {
        bool newState = false;

        switch (result) {
            case ConnectivityResult.mobile || ConnectivityResult.wifi:
                newState = true;
            case _:
                newState = false;
        }

        onStateDetected(newState: newState);
        });
    }

    void onStateDetected({required bool newState}) {
        if (state != newState) {
            state = newState;
        }
    }

    void onDispose() {
        ref.onDispose(() {
            _streamSubscription?.cancel();
            _streamSubscription = null;
        });
    }
}
</code></pre>
<p>UI Code 的部分跟 StreamProvider 不同，狀態不是 AsyncValue，可以直接拿來使用。</p>
<pre><code class="language-dart">@override
Widget build(BuildContext context) {
    final hasInternet = ref.watch(hasInternetNotifierProvider);

    return hasInternet ? const WelcomeInfoWidget() : const CircularProgressIndicator();
}
</code></pre>
<blockquote>
<p>其實此範例應該使用 AsyncNotifier 處理，因為一開始沒有取得當前狀態，透過 <code>checkConnectivity()</code> 的非同步操作取得，把它當成初始值。大家可以思考自己的需求，或是嘗試進行修改，過程會更熟悉更有趣。</p>
</blockquote>
<h2 id="分享一個開發技巧"><a class="header" href="#分享一個開發技巧">分享一個開發技巧</a></h2>
<p>在本文快結束的地方，順便分享一個好用的 UI 開發技巧，自定義 Extension Api 來協助我們。有經驗的朋友們應該知道 AsyncValue 是什麼，以及它的方便性，透過三種狀態來顯示指定元件。</p>
<p>當在 UI 處理了很多個 AsyncValue 後應該會發現有一些重複的程式碼，像是普遍 loading 跟 error 狀態都是相同的處理程序，這時候就可以將它們賦予預設動作，有效簡化開發。</p>
<p>範例：</p>
<ol>
<li>撰寫自定義的 <code>simpleWhen()</code>，在 <strong>loading</strong> 和 <strong>error</strong> 狀態設置預設的顯示元件，也包含其他 APP 預期的非同步操作</li>
<li>每次主要處理都是在 <strong>data</strong> 成功狀態，可以根據資料給予預設值， 像這裡就是如果遇到空資料就顯示特定文字，固定呈現方式，確保一致性</li>
<li>正常情況下只需要在呼叫時給予 <code>data()</code> callback 就完成 UI code，非常的簡潔、快速，省時又省力</li>
</ol>
<pre><code class="language-dart">extension AsyncValueExtension&lt;T&gt; on AsyncValue&lt;T&gt; {

    Widget simpleWhen({
        required Widget Function(T data) data,
        Widget? empty,
        bool skipLoadingOnReload = false,
        bool skipLoadingOnRefresh = false,
        bool skipError = false,
    }) =&gt;
        when(
            data: (tempData) {
                if (tempData is List) {
                    return tempData.isNotEmpty ? data(tempData) : Center(child: empty ?? const Text('目前沒有資料哦'));
                }

                return data(tempData);
            },
            loading: MyLoading.new,
            error: (error, stackTrace) =&gt; MyError(),
            skipLoadingOnReload: skipLoadingOnReload,
            skipLoadingOnRefresh: skipLoadingOnRefresh,
            skipError: skipError,
        );

}
</code></pre>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>到這裡應該篇幅稍長，最主要是想分享一些使用 Riverpod 的想法，它的靈活性很大，根據需求有各種實作方式，希望能讓大家更快的解決問題，並懂得如果操作每個 Provider 來幫助專案開發。Riverpod 本身很強大，但也很容易有自己的寫法，造成專案資料流的混亂，不像 Bloc 狀態管理有嚴謹的流程與限制，團隊這時候就需要統一規範，每個情境的開發想法才會一致，確保專案品質的標準。</p>
<p>最後，大家對於 Riverpod 開發技巧有興趣嗎？如何高效使用它，這個部分會再發佈另一篇文章來說明，大家可以期待一下！</p>
<hr />
<h2 id="延伸閱讀"><a class="header" href="#延伸閱讀">延伸閱讀</a></h2>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10332717">Day 17: Riverpod 是什麼？它負責狀態管理嗎？跟著我了解幾個重要角色</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10333398">Day 18: Flutter 狀態管理？Riverpod 的 watch() 實際上如何通知更新？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10333935">Day 19: 如何撰寫 Riverpod 測試，使用 Mocktail 來幫助我們吧！</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day19.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day21.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day19.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day21.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
