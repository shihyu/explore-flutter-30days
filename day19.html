<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Day 19: 如何撰寫 Riverpod 測試，使用 Mocktail 來幫助我們吧！ - Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-19-如何撰寫-riverpod-測試使用-mocktail-來幫助我們吧"><a class="header" href="#day-19-如何撰寫-riverpod-測試使用-mocktail-來幫助我們吧">Day 19: 如何撰寫 Riverpod 測試，使用 Mocktail 來幫助我們吧！</a></h1>
<ul>
<li>發布時間：2023-10-04 07:34:27</li>
<li>原文連結：<a href="https://ithelp.ithome.com.tw/articles/10333935">https://ithelp.ithome.com.tw/articles/10333935</a></li>
<li>系列標記：探索 Flutter 由裡到外，三十天帶你前往進階系列 第 19 篇</li>
</ul>
<p><img src="images/20120687WHgv6JnSGx.png" alt="" /></p>
<p>本文進入測試環節。適合對 Riverpod 有實際玩過且熟悉的朋友們，不會特別講解相關開發技巧，我們著重在於如何寫好一個基本的測試，穩固專案的品質。希望由這些範例讓大家更有感，對寫測試不害怕而且喜歡，相信對於自己的專案會有所幫助。</p>
<p>過程中會使用到 <strong>Mocktail</strong> 套件，一個 Dart 的測試模擬工具，由 Bloc 作者 <strong>Felix Angelov</strong> 製作。Mocktail 提供很多簡單使用的 API，讓我們可以輕鬆偽造動作與資料，不需要自己撰寫 Mock Data 或是 Codegen 生成 (就像 <strong>mockito</strong> 套件)。</p>
<hr />
<h2 id="前置說明"><a class="header" href="#前置說明">前置說明</a></h2>
<h4 id="providerlistener"><a class="header" href="#providerlistener">ProviderListener</a></h4>
<p>在驗證測試的過程中我們會需要 ProviderSubscription 的 <code>listen()</code> 函式，負責監聽 Provider 的狀態變化，利於在測試裡檢查狀態的更新，是否跟我們邏輯流程裡期望的結果一樣。</p>
<p>而在開始之前，首先需要自定義一個 <strong>ProviderListener</strong>，它負責 <code>listen()</code> 函式裡的 callback，包含兩個參數，第一個為上一個狀態，第二個為新的狀態。驗證的過程都可以透過它知道 callback 被呼叫幾次，以及狀態是否符合期望。</p>
<pre><code class="language-dart">// Mock listener
class ProviderListener&lt;T&gt; extends Mock {
  void call(T? previous, T? next);
}
</code></pre>
<p>以下是後面會看到的實際範例，由 <strong>listener</strong> 進行驗證</p>
<pre><code class="language-dart">// Use Container to listen specific Provider status
providerContainer.listen( 
 testAppThemeModeProvider, 
 listener, 
 fireImmediately: true, 
);
</code></pre>
<h4 id="futureprovider"><a class="header" href="#futureprovider"><strong>FutureProvider</strong></a></h4>
<ul>
<li>狀態是 AsyncValue，包含 <strong>AsyncLoading</strong>、<strong>AsyncData</strong>、<strong>AsyncError</strong></li>
</ul>
<h4 id="asyncnotifierprovider"><a class="header" href="#asyncnotifierprovider"><strong>AsyncNotifierProvider</strong></a></h4>
<ul>
<li>狀態是 AsyncValue，包含 <strong>AsyncLoading</strong>、<strong>AsyncData</strong>、<strong>AsyncError</strong></li>
<li><code>build()</code> → 負責初始化，允許進行非同步操作，返回 <strong>FutureOr</strong> 型別資料</li>
</ul>
<hr />
<h2 id="example-1-futureprovider"><a class="header" href="#example-1-futureprovider">Example 1 (FutureProvider)</a></h2>
<h3 id="情境"><a class="header" href="#情境">情境</a></h3>
<p>從本地儲存取得 APP 上次保存的 ThemeMode，透過它可以知道裝置為 light 還是 dark<br />
<img src="images/20120687rX9lOpUQt0.png" alt="" /></p>
<h3 id="實作"><a class="header" href="#實作"><strong>實作</strong></a></h3>
<p>首先在每個測試執行前初始化一些物件，進行前置作業。需要 <strong>ProviderContainer</strong> 存取每個 Provider、每個狀態，接著因為此測試要取得本地儲存的資料，需要偽造使用到的 LocalStorage，透過 overrides 覆蓋為 <strong>MockLocalStorage</strong>，準備測試使用。<br />
<img src="images/20120687ve4TaDEvYr.png" alt="" /></p>
<p><code>makeProviderContainer()</code> → 方便在初始化時使用，只需給予要偽造的 Provider，以及在測試結束後釋放資源</p>
<pre><code class="language-dart">ProviderContainer makeProviderContainer({required List&lt;Override&gt; overrides}) {
    final container = ProviderContainer(overrides: overrides);
    addTearDown(container.dispose);

    return container;
}
</code></pre>
<p>當使用 <code>storage.get()</code> 的時候我想要它返回指定資料，這邊設置為 <strong>true</strong><br />
<img src="images/20120687qwfRV2AU7M.png" alt="" /></p>
<p>創建一個 Listener，資料類型為 Provider 提供的資料，透過 container 監聽此狀態，利於我們檢查狀態的更新<br />
<img src="images/20120687ii9bxrJu28.png" alt="" /></p>
<p>此測試的主角 appThemeModeProvider 本身是 FutureProvider，在還沒完成之前的狀態都是 null 到 Loading，透過 <code>verify()</code> 和 <code>expect()</code> 進行初步確認</p>
<ol>
<li>
<p><code>verify()</code> 用來驗證狀態的更新</p>
</li>
<li>
<p><code>expect()</code> 用來檢查目前的 Provider 狀態，跟我們期望是否相同<br />
<img src="images/20120687noBbEbzTuE.png" alt="" /></p>
</li>
<li>
<p>完成非同步操作，從 MockLocalStorage 取得資料並返回 ThemeMode</p>
</li>
<li>
<p>驗證 Provider 狀態，從 AsyncLoading 到 AsyncData，並取得 <code>ThemeMode.light</code>，因為前面 Mock 的時候我們希望能拿到 true</p>
</li>
<li>
<p>期望 Provider 狀態，目前的狀態是 AsyncData，內容為 <code>ThemeMode.light</code><br />
<img src="images/20120687efZ49T0Bt6.png" alt="" /></p>
</li>
</ol>
<p>最後驗證 Listener 是不是沒有狀態的更新了，而且存取 LocalStorage 的操作只有一次<br />
<img src="images/20120687vGuWXwZR9k.png" alt="" /></p>
<p>測試運行成功！<br />
<img src="images/201206873Po7NVGf2x.png" alt="" /></p>
<p>以下為範例程式碼：</p>
<pre><code class="language-dart">test(
'Get ThemeMode(light) of APP',
    () async {
    /// arrange
    when(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).thenAnswer((_) =&gt; Future.value('true'));

    /// run
    final listener = ProviderListener&lt;AsyncValue&lt;ThemeMode&gt;&gt;();
    providerContainer.listen(
      appThemeModeProvider,
      listener,
      fireImmediately: true,
    );

    // Check state before completing future
    // 1. by verify
    verify(() =&gt; listener(null, const AsyncLoading&lt;ThemeMode&gt;()));
    // 2. by expect
    expect(providerContainer.read(appThemeModeProvider), const AsyncLoading&lt;ThemeMode&gt;());

    // Finish the future operation
    await providerContainer.read(appThemeModeProvider.future);

    // Check state when future completed.
    // 1.
    verify(
      () =&gt; listener(
        const AsyncLoading&lt;ThemeMode&gt;(),
        const AsyncData&lt;ThemeMode&gt;(ThemeMode.light),
      ),
    );
    // 2.
    expect(
      providerContainer.read(appThemeModeProvider),
      const AsyncData&lt;ThemeMode&gt;(ThemeMode.light),
    );

    // No new status
    verifyNoMoreInteractions(listener);

    // Only be called one time
    verify(() =&gt; storage.get(any())).called(1);
  },
);
</code></pre>
<h2 id="example-2-asyncnotifierprovider"><a class="header" href="#example-2-asyncnotifierprovider">Example 2 (AsyncNotifierProvider)</a></h2>
<h3 id="情境-1"><a class="header" href="#情境-1">情境</a></h3>
<p>本範例一樣是從本地取得 APP 保存的 ThemeMode，不同的是，這裡使用 <strong>AsyncNotifier</strong> 在 <code>build()</code> 初始化時從本地取得 ThemeMode，並設置初始狀態。AppThemeModeNotifier 經由 <code>appThemeModeNotifierProvider</code> 提供<br />
<img src="images/20120687iqbg6dDM38.png" alt="" /><br />
<img src="images/20120687d5BXjUKKoS.png" alt="" /></p>
<h3 id="實作-1"><a class="header" href="#實作-1">實作</a></h3>
<p>通常一開始都是先使用 <code>when()</code> 和 <code>then()</code> 相關 API，進行操作的資料偽照。接著透過 <code>listen()</code> 進行 Provider 狀態的監聽<br />
<img src="images/20120687jSSe29CITg.png" alt="" /></p>
<ol>
<li>首先驗證初始狀態，一樣是 null 到 <strong>AsyncLoading</strong>，並確認之後沒有新的狀態更新了</li>
<li>因為 <code>appThemeModeNotifierProvider</code> 類型是 <strong>AsyncNotifierProvider</strong>，這邊使用 await future 等待初始化完成，再進行結果檢查，預期拿到的數值是 <strong>ThemeMode.light</strong></li>
<li>最後確認資料只有被存取過一次<br />
<img src="images/20120687ezxrpy2PJa.png" alt="" /></li>
</ol>
<p>測試運行成功<br />
<img src="images/20120687an0wpCAfLs.png" alt="" /></p>
<p>以下為範例程式碼：</p>
<pre><code class="language-dart">test(
  'initialize in build() and get ThemeMode.light',
  () async {
    /// arrange
        when(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).thenAnswer((_) async =&gt; 'true');
    
        /// run
    final listener = ProviderListener&lt;AsyncValue&lt;ThemeMode&gt;&gt;();

    // Listen testAppThemeModeProvider to check status later.
    providerContainer.listen(
      appThemeModeNotifierProvider,
      listener,
      fireImmediately: true,
    );

    // In the beginning, always from null data to Loading state.
    verify(() =&gt; listener(null, const AsyncLoading()));
    verifyNoMoreInteractions(listener);

    // Complete build() of AsyncNotifier.
    // Need to use expectLater() to check current state.
    await expectLater(await providerContainer.read(appThemeModeNotifierProvider.notifier).future, ThemeMode.light);

    // Try to get local data from local storage in build().
    verify(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).called(1);
  },
);
</code></pre>
<h2 id="example-3-asyncnotifierprovider-and-exception"><a class="header" href="#example-3-asyncnotifierprovider-and-exception">Example 3 (AsyncNotifierProvider and Exception)</a></h2>
<h3 id="情境-2"><a class="header" href="#情境-2">情境</a></h3>
<p>新增 <code>toggleMode()</code> 目的為切換 App 的 ThemeMode，驗證過程中在拋出例外後的狀態更新與流程是否正常<br />
<img src="images/20120687gl9HodyZlo.png" alt="" /></p>
<h3 id="實作-2"><a class="header" href="#實作-2">實作</a></h3>
<p>在測試一開始先安排資料預期的輸出，在存取本地資料的時候希望拋出例外<br />
<img src="images/20120687BcBiSQBPZz.png" alt="" /></p>
<p>當 <code>listen()</code> 指定 Provider 狀態的時候，就開始進行 <code>build()</code> 的初始化，這時候會去存取 LocalStorage，所以先檢查是否已經呼叫一次<br />
<img src="images/20120687ZXBIFsVb7E.png" alt="" /></p>
<p>當存取 LocalStorage 的時候，期望獲得一個例外，可以使用 <code>throwA(isA&lt;Exception&gt;())</code><br />
<img src="images/20120687pqfGpdDXFb.png" alt="" /></p>
<p>檢查兩個狀態更新</p>
<ol>
<li>第一個情境，在取得目前的 ThemeMode 之前會先更新為 <strong>AsyncLoading</strong> 狀態</li>
<li>第二個情境，從 AsyncLoading 準備取得資料，這時候存取資料會拋出例外，是我們安排的情況，Provider 狀態會更新成有錯誤。錯誤的檢查方式使用 <code>predicate()</code>，確認其中 AsyncValue 是否有錯誤，有的話才符合我們要的流程</li>
<li>最後確認資料只有被存取過一次<br />
<img src="images/20120687D3XJtGqbrk.png" alt="" /></li>
</ol>
<p>也可以用另外一種方式，檢查狀態型別是否正確</p>
<pre><code class="language-dart">() =&gt; listener(
    const AsyncLoading(),
    any(
        that: isA&lt;AsyncError&lt;ThemeMode&gt;&gt;(),
    ),
),
</code></pre>
<p>測試運行成功！<br />
<img src="images/20120687kx5WwwrogO.png" alt="" /></p>
<p>以下為範例程式碼：</p>
<pre><code class="language-dart">test(
  'call toggleMode() but throw exception.',
  () async {
    /// arrange

    when(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).thenThrow(Exception('Can not get theme!'));
    when(() =&gt; storage.set(LocalStorageKeys.isLightTheme, any&lt;bool&gt;())).thenAnswer((invocation) =&gt; Future.value());

    /// run

    final listener = ProviderListener&lt;AsyncValue&lt;ThemeMode&gt;&gt;();
    providerContainer.listen(
      appThemeModeNotifierProvider,
      listener,
      fireImmediately: true,
    );

    // When listen the provider, it will initialize and run build()
    verify(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).called(1);

    await expectLater(() async =&gt; providerContainer.read(appThemeModeNotifierProvider.notifier).toggleMode(), throwsA(isA&lt;Exception&gt;()));

    verifyInOrder([
      // Beginning set the loading state
      () =&gt; listener(null, const AsyncLoading()),
      // Error will appear when complete
      () =&gt; listener(
            const AsyncLoading(),
            any(
              that: predicate&lt;AsyncValue&lt;void&gt;&gt;(
                (value) {
                  expect(value.hasError, true);

                  return true;
                },
              ),
            ),
          ),
    ]);

    // Call storage.get() again
    verify(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).called(1);
    
  },
);
</code></pre>
<h2 id="example-4-asyncnotifierprovider-and-stream"><a class="header" href="#example-4-asyncnotifierprovider-and-stream">Example 4 (AsyncNotifierProvider and Stream)</a></h2>
<h3 id="情境-3"><a class="header" href="#情境-3">情境</a></h3>
<p>在初始 <code>build()</code> 和 <code>toggleMode()</code> 進行 <strong>Stream</strong> 更新，取得目前的 ThemeMode，檢查狀態是否有按照期望的流程更新<br />
<img src="images/20120687B4xBsLt0JT.png" alt="" /><br />
<img src="images/20120687s1MfObf2jv.png" alt="" /></p>
<h3 id="實作-3"><a class="header" href="#實作-3">實作</a></h3>
<p>依正常流程來說此範例會存取本地資料 3 次，進行呼叫的次數驗證</p>
<ol>
<li>
<p>因為 Notifier 初始化的關係，一開始在 <code>build()</code> 裡存取資料，取得目前設定的 ThemeMode</p>
</li>
<li>
<p>第二次是在呼叫 <code>toggleMode()</code> 時，一開始也會取得資料</p>
</li>
<li>
<p>第三次則是再更新 ThemeMode 後，刷新 <code>appThemeModeProvider</code>，一樣需要存取本地資料。實際上是否要有這個 Provider 狀態還是根據實際開發需求，這裡只是做個範例展示<br />
<img src="images/20120687GuqsnFT4CV.png" alt="" /></p>
</li>
<li>
<p>檢查 Stream 資料流，我們期望它能照流程給予狀態。先是原本的 ThemeMode.light，再來點擊切換樣式後，更新成 ThemeMode.dark</p>
</li>
<li>
<p>最後再次驗證 storage 被存取的次數，在這邊為一次<br />
<img src="images/20120687JYizdeB1Ya.png" alt="" /></p>
</li>
</ol>
<p>測試運行成功！<br />
<img src="images/20120687ZJ2wkcVghg.png" alt="" /></p>
<p>以下為範例程式碼：</p>
<pre><code class="language-dart">test(
  'call toggleMode() and check stream data is correct',
  () async {
    /// arrange
    when(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).thenAnswer((_) async =&gt; Future.value('true'));
    when(() =&gt; storage.set(LocalStorageKeys.isLightTheme, any&lt;bool&gt;())).thenAnswer((invocation) =&gt; Future.value());

    /// run
    await providerContainer.read(appThemeModeNotifierProvider.notifier).toggleMode();

    // call once in build()
    // call once in toggleMode()
    // call once in appThemeModeProvider
    verify(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).called(3);

    expect(
      providerContainer.read(appThemeModeNotifierProvider.notifier).currentModeStream,
      emitsInOrder(
        const [
          ThemeMode.light,
          ThemeMode.dark,
        ],
      ),
    );

    // call once in build()
    verify(() =&gt; storage.get(LocalStorageKeys.isLightTheme)).called(1);
    
  },
);
</code></pre>
<p>注意：如果是使用 <code>expectLater()</code> 來檢查結果的話需要先在操作前定義好，等待操作後的結果，這樣寫測試比較不自然。建議用 <code>expect()</code>，可以在操作後進行檢查</p>
<hr />
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ul>
<li><strong>盡可能的給予泛型</strong>，將型別描述出來，方便閱讀以及查找問題</li>
<li>無法確保實際值的時候使用 <code>any()</code> 幫助檢查</li>
<li>使用 <strong>ProviderSubscription</strong> 搭配自訂義的 <strong>ProviderListener</strong>，監聽 Provider 狀態變化，方便檢查</li>
<li>每個測試可以新增自定義的 <code>timeout</code> 參數，確保我們的測試在需要時<strong>快速失敗</strong>，不會卡住流程</li>
</ul>
<p>將一些重複的操作優化成 Extension API，除了方便外，穩定性、可度性都能提高。</p>
<pre><code class="language-dart">/// For flutter_test
extension FinderMatchExtension on Finder {
    void never() =&gt; expect(this, findsNothing);
    void once() =&gt; expect(this, findsOneWidget);
    void times(int number) =&gt; expect(this, findsNWidgets(number));
    void some() =&gt; expect(this, findsWidgets);
}

/// For mocktail
extension VerificationCalledExtension on VerificationResult {
    void never() =&gt; called(0);
    void once() =&gt; called(1);
    void twice() =&gt; called(2);
    void threeTimes() =&gt; called(3);
    void times(int number) =&gt; called(number);
}
</code></pre>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>在使用 <code>any()</code> 或 <code>captureAny()</code> 時可能會出現的錯誤</p>
<pre><code class="language-bash">Bad state: A test tried to use `any` or `captureAny` on a parameter of type `AsyncValue&lt;void&gt;`, but
registerFallbackValue was not previously called to register a fallback value for `AsyncValue&lt;void&gt;`.
</code></pre>
<p>需要 <code>registerFallbackValue()</code>，否則無法作為值分配給不可為 null 的參數。如果此型別在很多測試裡都會使用到，可以在所有測試執行前進行設置</p>
<pre><code class="language-dart">setUpAll(() {
    registerFallbackValue(const AsyncLoading&lt;void&gt;());
});
</code></pre>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>到這裡大家覺得測試好玩嗎？有沒有接受並開始懂的如何寫了呢？其實，不管自己和公司專案有沒有在寫測試，或是有 QA 在幫忙，都應該要重視這一塊。當我們針對邏輯、操作流程、元件做了一層保護，開發、維護上也會更有保障，不是靠其他人驗證就沒問題，我們也不用提心吊膽的進行改版更新。應該讓自己慢慢養成寫測試的習慣，如何在時間與需求的壓力下讓專案趨近於完整和高品質，一直是開發者的課題。</p>
<p>也期許未來能夠看到更多有關測試的經驗談，之後也會在撰寫另一篇有關測試技巧的內容，歡迎大家提出來討論，分享踩坑紀錄，我想應該蠻有趣的！</p>
<p><a href="https://github.com/chyiiiiiiiiiiii/test_riverpod_with_mocktail?source=post_page-----d67cedbb2722--------------------------------">Github</a></p>
<hr />
<h2 id="延伸閱讀"><a class="header" href="#延伸閱讀">延伸閱讀</a></h2>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10332717">Day 17: Riverpod 是什麼？它負責狀態管理嗎？跟著我了解幾個重要角色</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10333398">Day 18: Flutter 狀態管理？Riverpod 的 watch() 實際上如何通知更新？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10334626">Day 20: Riverpod 的開發多元性以及日常使用技巧！Provider 該如何選擇？</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day18.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day20.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day18.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day20.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
