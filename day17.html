<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Day 17: Riverpod 是什麼？它負責狀態管理嗎？跟著我了解幾個重要角色 - Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flutter 鐵人賽 60 天合輯：由裡到外 × 進擊之路</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-17-riverpod-是什麼它負責狀態管理嗎跟著我了解幾個重要角色"><a class="header" href="#day-17-riverpod-是什麼它負責狀態管理嗎跟著我了解幾個重要角色">Day 17: Riverpod 是什麼？它負責狀態管理嗎？跟著我了解幾個重要角色</a></h1>
<ul>
<li>發布時間：2023-10-02 13:01:00</li>
<li>原文連結：<a href="https://ithelp.ithome.com.tw/articles/10332717">https://ithelp.ithome.com.tw/articles/10332717</a></li>
<li>系列標記：探索 Flutter 由裡到外，三十天帶你前往進階系列 第 17 篇</li>
</ul>
<p><img src="images/20120687xcOrJNKIlp.png" alt="" /></p>
<p>在 Flutter，狀態管理對於專案來說很重要，不是說一定要用，只是當開發者還不熟悉 Flutter 原理以及刷新觀念，很容易會造成不當開發的效能問題。狀態管理的職責就是讓開發者很輕鬆、容易地去管理狀態，並完成精準更新，省時省力且提升效能。Flutter 本身有提供一些開箱即用的功能<strong>InheritedWidget</strong>、<strong>ChangeNotifier</strong>、<strong>ValueListenableBuilder</strong> 等等，已經可以透過它們實現一個 APP，但是這些 API 總有可改進可加強的部分。</p>
<p>目前在 <a href="http://pub.dev">pub.dev</a> 上的狀態管理套件、框架非常多，大概20種以上，比較普遍大家知道幾個，Bloc、Riverpod、StateNotifier、Redux、Stacked、MobX、GetX 和 Provider，其實 Riverpod 主要職責不太屬於狀態管理，只是它有這個能力，詳細我們可以另開文章來聊。</p>
<p>對於開發者來說，尤其是剛入門的朋友，都會不知道要從哪個開始學習，當然基本的可以從知名度、like 數量去判斷。而在幾年的 Flutter 經驗裡，可以跟大家分享幾個主流選擇。目前最多產品、企業使用的是 Bloc，以固定流程、嚴謹規範搭配簡單的實作方式，我想是團隊的第一選擇，靈活性沒這麼高但是很穩固。接著第二個選擇是 <strong>Riverpod</strong> 也是本文的主題。</p>
<p>Riverpod 為 <strong>Provider</strong>、<strong>freezed</strong> 原作者 <strong>Remi Rousselet</strong> 所製作，在 Flutter 領域貢獻良多的一位開發者，為了改善 Provider 許多缺點所以有了 Riverpod，而它也是目前主推的狀態管理選項。加上作者本身非常活躍，頻繁與社群互動、表達自己的開發想法，常在各大研討會出現。對於一個開源維護者來說，這點讓使用者很安心，所以近幾年 Riverpod 聲量很高，使用人數持續成長，各種教學資源與範例也持續出現。</p>
<p>到這裡，前面講了這麼多，到底 Riverpod 特別在哪裡，應該很好奇吧？以及如何在專案裡使用它？我為什麼喜歡使用它來開發？趕快往下了解吧！</p>
<blockquote>
<p><a href="https://docs-v2.riverpod.dev/">Riverpod</a></p>
</blockquote>
<hr />
<p><img src="images/20120687gqjdeQctPQ.png" alt="" /></p>
<p>Riverpod <strong>is a reactive caching and data-binding framework</strong>。在官網第一眼看到的說明，有發現沒有 State Management 嗎，其實它本身不是狀態管理框架，而是進行響應式緩存以及數據綁定，不是以管理狀態為主軸，但是它有這個能力。這是 “鳥” 與 “鴿” 的問題，當大家說 “狀態管理”（鳥）時，有些人想到的是 “雞”，而 Riverpod 其實是 “鴿子”。Riverpod 可以作為狀態管理者，但很明顯地，它可以做的事更多。大家很常將它認定為狀態管理其實作者也無奈呀。</p>
<p>Riverpod 能夠幫忙處理大部分邏輯，也可以輕鬆執行執行網絡請求或非同步操作，支援錯誤處理和緩存，同時可以執行主動和被動的資源釋放。</p>
<h2 id="說明"><a class="header" href="#說明"><strong>說明</strong></a></h2>
<p>如果 Provider 是 <strong>InheritedWidget</strong> 的簡化，那麼 <strong>Riverpod</strong> 就是從頭開始對 <strong>InheritedWidget</strong> 的重新實現。</p>
<blockquote>
<p>如果 Provider 是蠟燭，那麼 Riverpod 就是燈泡。它們的用途非常相似，但我們不能通過改進蠟燭來製造燈泡。</p>
</blockquote>
<h3 id="riverpod-保有-provider-特色與自身優點"><a class="header" href="#riverpod-保有-provider-特色與自身優點">Riverpod 保有 Provider 特色，與自身優點</a></h3>
<ul>
<li>Riverpod 提供的 Provider 不是 Widget，在 Widget Tree 之外管理 Provider 生命週期，從頭實現了所有的狀態處理機制，沒有依賴 Flutter。它是一個 Dart 物件，所以允許在純 Dart 環境下運行</li>
<li>能夠安全地創建、觀察和結束狀態，不必擔心在 Widget 重建時狀態消失</li>
<li>組合狀態，在其中一個狀態更新時作出反應</li>
<li>當有多個 InheritedWidget 時提高可讀性</li>
<li>通過單向數據流使應用更具擴展性</li>
<li>所有 Provider 狀態都存儲在 ProviderContainer，由 ProviderScope 創建</li>
<li>幫 Widget 區塊綁定狀態裡的某個數值，當此數值更新時 UI 才會刷新，實現 Data Binding</li>
</ul>
<h3 id="比-provider-更好的部分"><a class="header" href="#比-provider-更好的部分">比 Provider 更好的部分</a></h3>
<ul>
<li>讀取的物件實體是<strong>編譯安全的</strong>，編譯時就能找出問題，不需要擔心有運行異常，例如：沒有 Provider 創建，進行存取時會有的 <strong>ProviderNotFoundException</strong></li>
<li>Riverpod 使用 InheritedWidget 實現，但獨立於 Flutter 之外，使 Provider 模式更加靈活。其實內部有使用 <code>context</code></li>
<li>能夠擁有多個相同型別的 Provider</li>
<li>Provider 可以依賴或監聽其他 Provider</li>
<li>可以讓每個狀態都是一個 Provider，或是由 Notifier Provider 去管理多個狀態</li>
<li>沒有使用 Provider 的時候，主動銷毀，實現記憶體釋放。甚至可以自行清除狀態</li>
<li>可以將 Provider 設置成 private，只屬於某個檔案或 library</li>
<li>測試流程很好進行模擬、資料偽造與驗證</li>
<li>輕鬆管理異步狀態，使用方式類似 RxDart 的 Subject</li>
</ul>
<h2 id="api-重點"><a class="header" href="#api-重點">API 重點</a></h2>
<h3 id="providerscope"><a class="header" href="#providerscope">ProviderScope</a></h3>
<ul>
<li>本身為一個 StatefulWidget，負責儲存所有 Provider 提供的狀態，透過自身創建的 <strong>ProviderContainer</strong> 進行儲存</li>
<li>使用時會在 Widget Tree 根部包裹一個 <strong>ProviderScope</strong> 或是 <strong>UncontrolledProviderScope</strong>，相當於啟動 Riverpod，是個必須的前置作業</li>
<li>ProviderScope 除了在根部以外，可以再多個地方重複使用，讓一些 Provider 狀態只限於某個 Widget Tree，不會共享於整個 APP</li>
<li>屬性
<ul>
<li><code>parent</code> → ProviderContainer，當我們有其他 ProviderScope 要使用時，可以透過 parent 給予原有的 ProviderContainer，能夠讓 Sub-ProviderContainer 繼續使用原本的所有 Provider 以及狀態</li>
<li><code>observers</code> → 自定義 ProviderObserver，在這個 ProviderScope 裡進行一些 Provider 更新的監聽</li>
<li><code>overrides</code> → 在當前 ProviderScope 裡複寫原有的 Provider，替代原有的數據</li>
<li><code>child</code> → 包裹元件、Widget Tree</li>
</ul>
</li>
</ul>
<p><img src="images/20120687pzhBnscjV9.png" alt="" /></p>
<h3 id="uncontrolledproviderscope"><a class="header" href="#uncontrolledproviderscope">UncontrolledProviderScope</a></h3>
<ul>
<li>通常一樣在 Widget Tree 根部使用，替代 ProviderScope，將 ProviderContainer 暴露給 Widget Tree，讓我們可以自行創建和直接操作它，做一些處理之後再設置給 ProviderScope</li>
<li>本身是 InheritedWidget，大部分 API 操作都會經過它，例如：<code>ref.watch()</code>、<code>ref.read()</code>、<code>Consumer</code>，透過 context 在 Element Tree 上取得 ProviderContainer 內容</li>
</ul>
<p><img src="images/20120687aZyJWwkDPq.png" alt="" /></p>
<h3 id="providercontainer"><a class="header" href="#providercontainer">ProviderContainer</a></h3>
<ul>
<li>負責儲存所有 Provider 的狀態，大部分的 Provider 操作都會透過 context 存取 ProviderContainer</li>
<li>正常開發中不會去直接面對它，在 ProviderScope 裡會自然被創建，當然也可以在 UncontrolledProviderScope 使用自己的 ProviderContainer</li>
</ul>
<p>一般可以使用 <code>ProviderScope.containerOf(context, listen = xx)</code> 靜態方法拿到 <strong>ProviderContainer</strong>，不同的是 listen 的值。如果沒有監聽需求，<code>listen</code> 參數為 false，接著使用 <code>getElementForInheritedWidgetOfExactType()</code> 方法，這樣在數據發生變化時元件就不會觸發 <code>didChangeDependencies()</code>，避免Widget執行不必要的重建。過程跟我們熟悉的 InheritedWidget 操作相同，需要監聽的話就會依賴 UncontrolledProviderScope，等待通知。<br />
<img src="images/20120687OGlEcDzREF.png" alt="" /><br />
<img src="images/20120687vfYqWrT7KV.png" alt="" /></p>
<h3 id="consumer"><a class="header" href="#consumer">Consumer</a></h3>
<ul>
<li>負責監聽 Provider 變化，一旦狀態更新會立即被通知，在 UI Code 使用</li>
<li>繼承 <strong>ConsumerWidget</strong>，需要透過它取得 WidgetRef</li>
<li><code>builder</code> → 一個 <strong>ConsumerBuilder</strong> typedef，提供 BuildContext、WidgetRef、Widget 三個參數，可以透過 WidgetRef 執行 <code>ref.read()</code>、<code>ref.watch()</code> 等 API，執行對 Provider 的操作</li>
</ul>
<p><img src="images/20120687fbF5hf6gnK.png" alt="" /></p>
<h3 id="consumerwidget"><a class="header" href="#consumerwidget">ConsumerWidget</a></h3>
<ul>
<li>類似 Flutter 擁有的 StatelessWidget，沒有狀態也無法執行 <code>setState()</code>，都是透過 WidgetRef 進行 Provider 與 狀態的操作，在 <code>build()</code> 方法會提供</li>
<li>繼承 <strong>ConsumerStatefulWidget</strong> 的抽象類別，將一些 API 方法隱藏起來，只暴露了 <code>build()</code> 給外部使用</li>
</ul>
<p><img src="images/20120687MdPJpIfpYp.png" alt="" /><br />
<img src="images/201206870CjhGckksS.png" alt="" /></p>
<h3 id="consumerstatefulwidget"><a class="header" href="#consumerstatefulwidget">ConsumerStatefulWidget</a></h3>
<p>實際上就是 Flutter 擁有的 StatefulWidget，只是一個繼承它的抽象類別，跟正常的用法都一樣。搭配 <strong>ConsumerState</strong>，只是 State 多了 WidgetRef 物件可以使用，一樣所有的操作都需要透過它進行</p>
<p><img src="images/201206874BM7jp7cLV.png" alt="" /><br />
<img src="images/20120687amKSEqta8e.png" alt="" /></p>
<h3 id="widgetref"><a class="header" href="#widgetref">WidgetRef</a></h3>
<ul>
<li>一個允許元件跟 Provider 互動的物件，透過它存取資料、執行任務處理，所有的狀態管理操作都需要經過 WidgetRef</li>
<li>抽象類別，提供許多常用的互動 API，例如：<code>exists()</code>、<code>read()</code>、<code>watch()</code>、<code>listen()</code>、<code>listenManual()</code>、<code>refresh()</code>、<code>invalidate()</code>，有經驗的朋友們應該對他們很熟悉吧。實際在使用他們的時候，內部還是使用了 <code>context</code>，因為前面提到 Tree Root 使用 <strong>InheritedWidget</strong>，便於在實作時從 <strong>Element Tree</strong> 取得指定 Provider，讓我們高效存取 <strong>ProviderContainer</strong>。</li>
</ul>
<p><img src="images/201206871Bxl79KLaB.png" alt="" /></p>
<ul>
<li>WidgetRef 本身其實也是 <strong>BuildContext</strong>，內部都是透過 context 轉型，讓開發者可以直接使用操作 API。對於 ConsumerWidget 和 ConsumerStatefulWidget 來說 BuildContext 就是 <strong>ConsumerStatefulElement</strong>，API 細節都在這裡面</li>
</ul>
<p><img src="images/20120687JQQfiI4kXU.png" alt="" /></p>
<p>以下為 API 簡易說明：</p>
<h4 id="exists"><a class="header" href="#exists">exists()</a></h4>
<p>檢查 Provider 是否已經初始化、是否有狀態了</p>
<h4 id="read"><a class="header" href="#read">read()</a></h4>
<p>取得 Provider 當前狀態，如果是第一次存取就會執行初始化，並緩存狀態</p>
<h4 id="watch"><a class="header" href="#watch">watch()</a></h4>
<p>監聽 Provider 狀態變化，一旦有更新，Widget 就會執行 rebuild，或是其他 Provider 進行狀態重整</p>
<h4 id="listen"><a class="header" href="#listen">listen()</a></h4>
<p>監聽 Provider 狀態變化，有更新的話，可以經由 callback 取得新舊資料，可以自行處理接下來的任務。例如：顯示 SnackBar、Dialog</p>
<h4 id="listenmanual"><a class="header" href="#listenmanual">listenManual()</a></h4>
<p>一樣是監聽 Provider 狀態變化，但跟 <code>listen()</code> 不同的是，不適用於 <code>build()</code> 方法裡使用，而是在 State 的 <code>initState()</code> 或是其他生命週期的位置。另外可以使用 <code>close()</code> 停止 Provider 監聽，在某些時候可以自行操控。</p>
<h4 id="invalidate"><a class="header" href="#invalidate">invalidate()</a></h4>
<p>讓 Provider 狀態消失、無效，確保下次 Provider 被存取時可以重新初始化</p>
<h4 id="refresh"><a class="header" href="#refresh">refresh()</a></h4>
<p>讓 Provider 重新獲取狀態，並返回最新資料。過程中使用了 <code>invalidate()</code>，先釋放並立即初始化取得狀態， 例子：重新請求 API</p>
<h3 id="autodispose--autodispose"><a class="header" href="#autodispose--autodispose">AutoDispose &amp; autoDispose</a></h3>
<p>資源自動釋放，是 Riverpod 的一大重點。我們可以幫 Provider 加上 <code>autoDispose</code> 修飾符，或是使用 Codegen 寫法(keepAlive 屬性預設為 false)，讓 Provider 發現沒有被使用的情況下進行釋放。有關此 <code>ProviderElement</code> 的狀態就會自動處理掉，因為不再需要了。</p>
<p>從源碼來看，通常有使用到 autoDispose 操作，背後都會 mixin <strong>AutoDisposeProviderElementMixin</strong>，其中的 <code>mayNeedDispose()</code> 就是關鍵，最終執行 <code>scheduleProviderDispose()</code>，安排釋放</p>
<ol>
<li>首先檢查 <code>maintainState</code> 屬性，這部分屬於舊版寫法，false 代表不保存狀態</li>
<li>檢查有沒有監聽者，可能是元件或是其他 Provider</li>
<li>現在都是使用 keepAlive 來判斷是否持續存活，如果沒有使用的話代表不保存狀態<br />
<img src="images/201206870KMs9SSYjM.png" alt="" /></li>
</ol>
<blockquote>
<p>之後可以在開一篇文章，我們來探討細部 API 背後所做的一舉一動，應該蠻有趣的</p>
</blockquote>
<hr />
<h2 id="範例"><a class="header" href="#範例">範例</a></h2>
<h3 id="自定義-providercontainer"><a class="header" href="#自定義-providercontainer">自定義 ProviderContainer</a></h3>
<ul>
<li>創建一個給 APP 和 Riverpod 使用的 <strong>ProviderContainer</strong>，可以優先使用它取得初始化 Provider 和服務，提早獲得狀態</li>
<li>呼叫 <code>container.read()</code> 創建類的實體並初始化，甚至可以更新狀態。很常見的情境是，有些服務的初始化需要非同步操作，可以將這類行為先完成後，再賦予完整狀態，這時候就可以使用 Provider，而不是 FutureProvider。例如：SharedPreference</li>
<li>將包裹APP的 <code>ProviderScope</code> 更換成 <code>UncontrolledProviderScope</code>，並設置 container 屬性，給予自定義的 ProviderContainer 物件</li>
</ul>
<pre><code class="language-dart">class AuthService {
    AuthService();

    Future&lt;void&gt; init() async {
        // Do something...
    }
}

final authServiceProvider = Provider&lt;AuthService&gt;((ref) {
    return AuthService()..init();
});

Future&lt;void&gt; main() async {
    final providerContainer = ProviderContainer();
    providerContainer.read(authServiceProvider);

    runApp(
        UncontrolledProviderScope(
            container: providerContainer,
            child: const MyApp(),
        ),
    );
}
</code></pre>
<h3 id="使用-overrides-覆蓋-provider-狀態"><a class="header" href="#使用-overrides-覆蓋-provider-狀態">使用 overrides 覆蓋 Provider 狀態</a></h3>
<p>ProviderContainer 提供了 <strong>overrides</strong> 參數，可以覆寫特定的 Provider，可以提早做一些操作和資料處理。或是進行非同步操作，接著覆蓋一個基本的 Provider，即可省略使用 FutureProvider。在測試時也很方便使用，用來偽造數據、偽照狀態。</p>
<pre><code class="language-dart">Future&lt;void&gt; main() async {
    final authService = AuthService();
    await authService.init();

    final providerContainer = ProviderContainer(
        overrides: [
            authServiceProvider.overrideWithValue(authService),
        ],
    );

    runApp(
        UncontrolledProviderScope(
            container: providerContainer,
            child: const MyApp(),
        ),
    );
}
</code></pre>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>開發 APP 過程中一定會有很多狀態，它們牽扯到了記憶體、運算、效能，如何正確管理和處理是個重要課題。在對的時機點使用，再不需要的時候進行釋放。Riverpod 對於複雜且龐大的 APP 來說是一個不錯的選擇，它擁有其他狀態管理套件的能力，加上自己獨有的一些特色，包含強大的靈活性(但同時也是個雙面刃)，能夠讓開發者很輕鬆地進行開發。只要你熟悉了，Riverpod 絕對能有效地給予幫助。</p>
<h2 id="延伸閱讀"><a class="header" href="#延伸閱讀">延伸閱讀</a></h2>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10333398">Day 18: Flutter 狀態管理？Riverpod 的 watch() 實際上如何通知更新？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10333935">Day 19: 如何撰寫 Riverpod 測試，使用 Mocktail 來幫助我們吧！</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10334626">Day 20: Riverpod 的開發多元性以及日常使用技巧！Provider 該如何選擇？</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day16.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day18.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day16.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day18.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
